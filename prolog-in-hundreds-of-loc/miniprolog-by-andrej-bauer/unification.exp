# These test cases were adapted from en.literateprograms.org/Unification_(QBASIC)
# The license of en.literateprograms.org was MIT/X11, but I don't think this is a copy or substantial portion,
# and MIT/X11 allows releasing derived works under a different license
spawn ./miniprolog
send "unifies(X,X).\n"
send "?- unifies(r(a,b),r(a,b)).\n"
expect "Yes"
send "?- unifies(r(a,b),e(a,b)).\n"
expect "No"
send "?- unifies(r(A,B),r(pair(C,D),D)).\n"
expect "A = pair(C,B)"
expect "D = B"
send "y\n"
expect "No"
send "?- unifies(r(A,B),r(pair(C,D),d)).\n"
expect "A = pair(C,D)"
expect "B = d"
send "y\n"
expect "No"
send "?- unifies(r(A,B),r(pair(B,D),d)).\n"
expect "A = pair(d,D)"
expect "B = d"
send "y\n"
expect "No"
send "?- unifies(r(A,C),r(pair(B,C),B)).\n"
expect "A = pair(C,C)"
expect "B = C"
send "y\n"
expect "No"
send "?- unifies(r(A,pair(b,c)),r(pair(B,C),B)).\n"
expect "A = pair(pair(b,c),C)"
expect "B = pair(b,c)"
send "y\n"
expect "No"
send "?- unifies(r(A,pair(d,e)),r(pair(B,C),B)).\n"
expect "A = pair(pair(d,e),C)"
expect "B = pair(d,e)"
send "y\n"
expect "No"
send "?- unifies(r(A,b),r(pair(C,D),D)).\n"
expect "A = pair(C,b)"
expect "D = b"
send "y\n"
expect "No"
send "?- unifies(r(a,b),r(X,b)).\n"
expect "X = a"
send "y\n"
expect "No"
send "?- unifies(q(p(X,Y),p(Y,X)),q(Z,Z)).\n"
expect "Z = p(Y,Y)"
expect "X = Y"
send "y\n"
expect "No"
send "?- unifies(p(X,Y),p(Y,X)).\n"
expect "Y = X"
send "y\n"
expect "No"
send "?- unifies(p(X,Y,A),p(Y,X,X)).\n"
expect "Y = A"
expect "X = A"
send "y\n"
expect "No"
