#include "minsky_register_machine.h"
#include <set>
#include <iostream>
#include <sstream>

// forward declarations
extern "C" {
  // these are generated by lemon
  void* ParseAlloc(typeof(malloc));
  void Parse(void* parser, int tokencode, const void* tokenvalue= NULL);
  void ParseFree(void* parser, typeof(free));

  // these are actions, called from the grammar
  void set_label(const char* label);
  void inc(const char* reg, const struct destination* next);
  void dec(const char* reg,
	   const struct destination* nonzero,
	   const struct destination* zero);
  struct destination* make_label(const char* name);
  struct destination* make_printable(const char* to_print);
  const char* make_var(const char* varname);
  void initialize(const char* reg, int value);
  void done();
}

// the set of variables to be declared
std::set<std::string> vars;
// the main flow of code
std::stringstream flow;
// the initializations
std::stringstream init;

// TODO: convert this to an interface and two classes
struct destination {
  int is_done; // actually a boolean
  const char* to_print;
  const char* name;

  void emit_jump() const {
    if (is_done) {
      flow << "puts(\"" << to_print << "\");\n";
      flow << "goto done;\n";
    } else {
      flow << "goto " << name << ";\n";
    }
  }
};

void set_label(const char* label) {
  flow << label << ":\n";
}

void inc(const char* reg, const struct destination* next) {
  flow << reg << "++;\n";
  next->emit_jump();
}

void dec(const char* reg,
	 const struct destination* nonzero,
	 const struct destination* zero) {
  flow << "if (" << reg << " > 0) {\n";
  flow << "--" << reg << ";\n";
  nonzero->emit_jump();
  flow << "} else {\n";
  zero->emit_jump();
  flow << "}\n";
}

struct destination* make_label(const char* name) {
  destination* answer= new destination;
  answer->is_done= 0; // false
  answer->to_print= "";
  answer->name= name;
  return answer;
}

struct destination* make_printable(const char* to_print) {
  destination* answer= new destination;
  answer->is_done= 1; // true
  answer->to_print= to_print;
  answer->name= "";
  return answer;
}

const char* make_var(const char* varname) {
  vars.insert(varname);
  return varname;
}

void initialize(const char* reg, int value) {
  init << reg << " = " << value << ";\n";
}

void done() {
  std::cout << "#include <stdio.h>\n";
  for (std::set<std::string>::iterator i= vars.begin();
       i != vars.end();
       ++i) {
    std::cout << "int " << *i << ";\n";
  }
  std::cout << "int main() {\n";
  std::cout << init.str();
  std::cout << flow.str();
  std::cout << "done:\n";
  std::cout << "printf(\"";
  bool first= true;
  for (std::set<std::string>::iterator i= vars.begin();
       i != vars.end();
       ++i) {
    if (first) {
      first= false;
    } else {
      std::cout << " ";
    }
    std::cout << *i << "=%d";
  }
  std::cout << "\\n\", ";
  first= true;
  for (std::set<std::string>::iterator i= vars.begin();
       i != vars.end();
       ++i) {
    if (first) {
      first= false;
    } else {
      std::cout << ", ";
    }
    std::cout << *i;
  }
  std::cout << ");\n";
  std::cout << "}\n";
}

int main() {
  void* parser= (void*)ParseAlloc(malloc);

  // TODO: write a lexer
  // s0 : a - s1 "Ok"
  Parse(parser, ID, "s0");
  Parse(parser, COLON);
  Parse(parser, ID, "a");
  Parse(parser, MINUS);
  Parse(parser, ID, "s1");
  Parse(parser, STRING, "Ok");
  Parse(parser, NEWLINE);

  // s1 : b + s0
  Parse(parser, ID, "s1");
  Parse(parser, COLON);
  Parse(parser, ID, "b");
  Parse(parser, PLUS);
  Parse(parser, ID, "s0");
  Parse(parser, NEWLINE);

  // a=3 b=4
  Parse(parser, ID, "a");
  Parse(parser, EQUALS);
  Parse(parser, NUMBER, (void*)3);
  Parse(parser, ID, "b");
  Parse(parser, EQUALS);
  Parse(parser, NUMBER, (void*)4);

  // EOF
  Parse(parser, 0);
  
  ParseFree(parser, free);
  return 0;
}
